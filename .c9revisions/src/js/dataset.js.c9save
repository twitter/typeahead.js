{"ts":1362740025014,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * typeahead.js\n * https://github.com/twitter/typeahead\n * Copyright 2013 Twitter, Inc. and other contributors; Licensed MIT\n */\n\nvar Dataset = (function() {\n\n  function Dataset(o) {\n    utils.bindAll(this);\n\n    this.storage = new PersistentStorage(o.name);\n    this.adjacencyList = {};\n    this.itemHash = {};\n\n    this.name = o.name;\n    this.resetDataOnProtocolSwitch = o.resetDataOnProtocolSwitch || false;\n    this.queryUrl = o.remote;\n    this.transport = o.transport;\n    this.limit = o.limit || 10;\n    this._customMatcher = o.matcher || null;\n    this._customRanker = o.ranker || null;\n    this._ttl_ms = utils.isNumber(o.ttl_ms) ? o.ttl_ms : 24 * 60 * 60 * 1000;\n\n    this.keys = {\n      version: 'version',\n      protocol: 'protocol',\n      itemHash: 'itemHash',\n      adjacencyList: 'adjacencyList'\n    };\n\n    o.local && this._processLocalData(o.local);\n    o.prefetch && this._loadPrefetchData(o.prefetch);\n  }\n\n  utils.mixin(Dataset.prototype, {\n\n    // private methods\n    // ---------------\n\n    _processLocalData: function(data) {\n      data && this._mergeProcessedData(this._processData(data));\n    },\n\n    _loadPrefetchData: function(url) {\n      var that = this,\n          itemHash = this.storage.get(this.keys.itemHash),\n          adjacencyList = this.storage.get(this.keys.adjacencyList),\n          protocol = this.storage.get(this.keys.protocol),\n          version = this.storage.get(this.keys.version),\n          isExpired = version !== VERSION || protocol !== utils.getProtocol();\n\n      // data was available in local storage, use it\n      if (itemHash && adjacencyList && !isExpired) {\n        this._mergeProcessedData({\n          itemHash: itemHash,\n          adjacencyList: adjacencyList\n        });\n      }\n\n      else {\n        $.getJSON(url).done(processPrefetchData);\n      }\n\n      function processPrefetchData(data) {\n        var processedData = that._processData(data),\n            itemHash = processedData.itemHash,\n            adjacencyList = processedData.adjacencyList;\n\n        // store process data in local storage\n        // this saves us from processing the data on every page load\n        that.storage.set(that.keys.itemHash, itemHash, that._ttl_ms);\n        that.storage.set(that.keys.adjacencyList, adjacencyList, that._ttl_ms);\n        that.storage.set(that.keys.version, VERSION, that._ttl_ms);\n        that.storage.set(that.keys.protocol, utils.getProtocol(), that._ttl_ms);\n\n        that._mergeProcessedData(processedData);\n      }\n    },\n\n    _processData: function(data) {\n      var itemHash = {}, adjacencyList = {};\n\n      utils.each(data, function(i, item) {\n        var id;\n\n        // convert string datums to datum objects\n        if (utils.isString(item)) {\n          item = { value: item, tokens: utils.tokenizeText(item) };\n        }\n\n        // filter out falsy tokens\n        item.tokens = utils.filter(item.tokens || [], function(token) {\n          return !utils.isBlankString(token);\n        });\n\n        // normalize tokens\n        item.tokens = utils.map(item.tokens, function(token) {\n          return token.toLowerCase();\n        });\n\n        itemHash[id = utils.getUniqueId(item.value)] = item;\n\n        utils.each(item.tokens, function(i, token) {\n          var character = token.charAt(0),\n              adjacency = adjacencyList[character] ||\n                (adjacencyList[character] = [id]);\n\n          !~utils.indexOf(adjacency, id) && adjacency.push(id);\n        });\n      });\n\n      return { itemHash: itemHash, adjacencyList: adjacencyList };\n    },\n\n    _mergeProcessedData: function(processedData) {\n      var that = this;\n\n      // merge item hash\n      utils.mixin(this.itemHash, processedData.itemHash);\n\n      // merge adjacency list\n      utils.each(processedData.adjacencyList, function(character, adjacency) {\n        var masterAdjacency = that.adjacencyList[character];\n\n        that.adjacencyList[character] = masterAdjacency ?\n          masterAdjacency.concat(adjacency) : adjacency;\n      });\n    },\n\n    _getPotentiallyMatchingIds: function(terms) {\n      var potentiallyMatchingIds = [];\n      var lists = [];\n      utils.map(terms, utils.bind(function(term) {\n        var list = this.adjacencyList[term.charAt(0)];\n        if (!list) { return; }\n        lists.push(list);\n      },this));\n      if (lists.length === 1) {\n        return lists[0];\n      }\n      var listLengths = [];\n      $.each(lists, function(i, list) {\n        listLengths.push(list.length);\n      });\n      var shortestListIndex = utils.indexOf(listLengths, Math.min.apply(null, listLengths)) || 0;\n      var shortestList = lists[shortestListIndex] || [];\n      potentiallyMatchingIds = utils.map(shortestList, function(item) {\n        var idInEveryList = utils.every(lists, function(list) {\n          return utils.indexOf(list, item) > -1;\n        });\n        if (idInEveryList) {\n          return item;\n        }\n      });\n      return potentiallyMatchingIds;\n    },\n\n    _getItemsFromIds: function(ids) {\n      var items = [];\n      utils.map(ids, utils.bind(function(id) {\n        var item = this.itemHash[id];\n        if (item) {\n          items.push(item);\n        }\n      }, this));\n      return items;\n    },\n\n    _matcher: function(terms) {\n      if (this._customMatcher) {\n        var customMatcher = this._customMatcher;\n        return function(item) {\n          return customMatcher(item);\n        };\n      } else {\n        return function(item) {\n          var tokens = item.tokens;\n          var allTermsMatched = utils.every(terms, function(term) {\n            var tokensMatched = utils.filter(tokens, function(token) {\n              return token.indexOf(term) === 0;\n            });\n            return tokensMatched.length;\n          });\n          if (allTermsMatched) {\n            return item;\n          }\n        };\n      }\n    },\n\n    _compareItems: function(a, b, areLocalItems) {\n      var aScoreBoost = !a.score_boost ? 0 : a.score_boost,\n      bScoreBoost = !b.score_boost ? 0 : b.score_boost,\n      aScore = !a.score ? 0 : a.score,\n      bScore = !b.score ? 0 : b.score;\n\n      if(areLocalItems) {\n        return (b.weight + bScoreBoost) - (a.weight + aScoreBoost);\n      } else {\n        return (bScore + bScoreBoost) - (aScore + aScoreBoost);\n      }\n    },\n\n    _ranker: function(a, b) {\n      if (this._customRanker) {\n        return this._customRanker(a, b);\n      } else {\n        // Anything local should always be first (anything with a non-zero weight) and remote results (non-zero scores), and sort by weight/score within each category\n        var aIsLocal = a.weight && a.weight !== 0;\n        var bIsLocal = b.weight && b.weight !== 0;\n        if (aIsLocal && !bIsLocal) {\n          return -1;\n        } else if (bIsLocal && !aIsLocal) {\n          return 1;\n        } else {\n          return (aIsLocal && bIsLocal) ? this._compareItems(a, b, true) : this._compareItems(a, b, false);\n        }\n      }\n    },\n\n    _processRemoteSuggestions: function(callback, matchedItems) {\n      var that = this;\n\n      return function(data) {\n        //convert remote suggestions to object\n        utils.each(data, function(i, remoteItem) {\n          var isDuplicate = false;\n\n          remoteItem = utils.isString(remoteItem) ?\n            { value: remoteItem } : remoteItem;\n\n          // checks for duplicates\n          utils.each(matchedItems, function(i, localItem) {\n            if (remoteItem.value === localItem.value) {\n              isDuplicate = true;\n\n              // break out of each loop\n              return false;\n            }\n          });\n\n          !isDuplicate && matchedItems.push(remoteItem);\n\n          // if we're at the limit, we no longer need to process\n          // the remote results and can break out of the each loop\n          return matchedItems.length < that.limit;\n        });\n\n        callback && callback(matchedItems);\n      };\n    },\n\n    // public methods\n    // ---------------\n\n    getSuggestions: function(query, callback) {\n      var terms = utils.tokenizeQuery(query);\n      var potentiallyMatchingIds = this._getPotentiallyMatchingIds(terms);\n      var potentiallyMatchingItems = this._getItemsFromIds(potentiallyMatchingIds);\n      var matchedItems = utils.filter(potentiallyMatchingItems, this._matcher(terms));\n      matchedItems.sort(this._ranker);\n      callback && callback(matchedItems);\n      if (matchedItems.length < this.limit && this.queryUrl) {\n        this.transport.get(this.queryUrl, query, this._processRemoteSuggestions(callback, matchedItems));\n      }\n    }\n  });\n\n  return Dataset;\n})();\n"]],"start1":0,"start2":0,"length1":0,"length2":8551}]],"length":8551}
